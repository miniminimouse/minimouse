import pandas as pd
import numpy as np
import statsmodels.api as sm
from sklearn.metrics import mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

def lgd_datastaging(orig_data, stage1_vars, stage2_vars, lgd_var, 
                   id_var='LOAN_NUMBER', date_var='def_date'):
    """
    Python implementation of SAS lgd_datastaging macro
    Creates properly staged data for two-stage LGD modeling
    
    Parameters:
    - orig_data: Original DataFrame
    - stage1_vars: List of stage 1 variables
    - stage2_vars: List of stage 2 variables  
    - lgd_var: Name of LGD variable
    - id_var: ID variable name
    - date_var: Date variable name
    
    Returns:
    - Dictionary containing stage1, stage2, and combined datasets
    """
    
    results = {}
    
    # Stage 1 dataset
    stage1_keep_vars = stage1_vars + [lgd_var, id_var, date_var]
    lgd_stage1 = orig_data[stage1_keep_vars].copy()
    lgd_stage1['wt'] = 1
    results['lgd_stage1'] = lgd_stage1
    
    # Stage 2 dataset  
    stage2_keep_vars = stage2_vars + [lgd_var, id_var, date_var]
    lgd_stage2 = orig_data[stage2_keep_vars].copy()
    lgd_stage2['wt'] = 1
    results['lgd_stage2'] = lgd_stage2
    
    # Combined dataset with all variables
    all_vars = list(set(stage1_vars + stage2_vars + [lgd_var, id_var, date_var]))
    lgd_stage_all = orig_data[all_vars].copy()
    lgd_stage_all['wt'] = 1
    results['lgd_stage_all'] = lgd_stage_all
    
    # Adding staging flags to stage1 dataset
    lgd_stage1_wf = lgd_stage1.copy()
    
    # Create LGD category flags
    lgd_stage1_wf['lgd_0'] = (lgd_stage1_wf[lgd_var] == 0).astype(int)
    lgd_stage1_wf['lgd_1'] = (lgd_stage1_wf[lgd_var] == 1).astype(int)
    lgd_stage1_wf['lgd_0_1'] = ((lgd_stage1_wf[lgd_var] > 0) & 
                                (lgd_stage1_wf[lgd_var] < 1)).astype(int)
    lgd_stage1_wf['lgd_0_1_inc'] = ((lgd_stage1_wf[lgd_var] > 0) & 
                                    (lgd_stage1_wf[lgd_var] <= 1)).astype(int)
    
    results['lgd_stage1_wf'] = lgd_stage1_wf
    
    # Adding staging flags to stage2 dataset
    lgd_stage2_wf = lgd_stage2.copy()
    
    # Create LGD category flags (same as stage1)
    lgd_stage2_wf['lgd_0'] = (lgd_stage2_wf[lgd_var] == 0).astype(int)
    lgd_stage2_wf['lgd_1'] = (lgd_stage2_wf[lgd_var] == 1).astype(int)
    lgd_stage2_wf['lgd_0_1'] = ((lgd_stage2_wf[lgd_var] > 0) & 
                                (lgd_stage2_wf[lgd_var] < 1)).astype(int)
    lgd_stage2_wf['lgd_0_1_inc'] = ((lgd_stage2_wf[lgd_var] > 0) & 
                                    (lgd_stage2_wf[lgd_var] <= 1)).astype(int)
    
    results['lgd_stage2_wf'] = lgd_stage2_wf
    
    # Adding staging flags to combined dataset
    lgd_stage_all_wf = lgd_stage_all.copy()
    
    # Create LGD category flags (same as above)
    lgd_stage_all_wf['lgd_0'] = (lgd_stage_all_wf[lgd_var] == 0).astype(int)
    lgd_stage_all_wf['lgd_1'] = (lgd_stage_all_wf[lgd_var] == 1).astype(int)
    lgd_stage_all_wf['lgd_0_1'] = ((lgd_stage_all_wf[lgd_var] > 0) & 
                                   (lgd_stage_all_wf[lgd_var] < 1)).astype(int)
    lgd_stage_all_wf['lgd_0_1_inc'] = ((lgd_stage_all_wf[lgd_var] > 0) & 
                                       (lgd_stage_all_wf[lgd_var] <= 1)).astype(int)
    
    results['lgd_stage_all_wf'] = lgd_stage_all_wf
    
    # Stage 1 y creation
    lgd_stage1_wf_wadj = lgd_stage1_wf.copy()
    
    # Create LGD_Stage1: 1 if lgd_var = 0, 2 if lgd_var > 0 (to match SAS)
    lgd_stage1_wf_wadj['LGD_Stage1'] = np.where(
        lgd_stage1_wf_wadj[lgd_var] == 0, 1, 2
    )
    
    # Create binary version for modeling: 1 if LGD_Stage1=2 (lgd_var>0), 0 if LGD_Stage1=1 (lgd_var=0)
    # This matches SAS ref='1' where the model predicts P(LGD_Stage1=2) = P(loss)
    lgd_stage1_wf_wadj['lgd_stage1'] = (lgd_stage1_wf_wadj['LGD_Stage1'] == 2).astype(int)
    
    results['lgd_stage1_wf_wadj'] = lgd_stage1_wf_wadj
    
    # Stage 2 algd_adj creation
    # Filter to only include cases where 0 < lgd_var <= 1
    mask = (lgd_stage2_wf[lgd_var] > 0) & (lgd_stage2_wf[lgd_var] <= 1)
    lgd_stage2_filtered = lgd_stage2_wf[mask].copy()
    
    # Create condition "a" rows: algd_adj=1, wt=lgd_var
    condition_a = lgd_stage2_filtered.copy()
    condition_a['algd_adj'] = 1
    condition_a['wt'] = condition_a[lgd_var]
    
    # Create condition "b" rows: algd_adj=0, wt=1-lgd_var
    condition_b = lgd_stage2_filtered.copy()
    condition_b['algd_adj'] = 0
    condition_b['wt'] = 1 - condition_b[lgd_var]
    
    # Combine both conditions
    lgd_stage2_wf_wadj = pd.concat([condition_a, condition_b], ignore_index=True)
    
    results['lgd_stage2_wf_wadj'] = lgd_stage2_wf_wadj
    
    return results

def performance_metrics(data, actual_var, pred_var, date_var=None):
    """
    Calculate performance metrics (MAE, RMSE) and return aggregated data for plotting
    
    Parameters:
    - data: DataFrame with actual and predicted values
    - actual_var: name of actual variable column
    - pred_var: name of predicted variable column  
    - date_var: name of date variable for aggregation (optional)
    
    Returns:
    - dict with MAE, RMSE, and aggregated data
    """
    # Calculate overall metrics
    mae = mean_absolute_error(data[actual_var], data[pred_var])
    rmse = np.sqrt(mean_squared_error(data[actual_var], data[pred_var]))
    
    results = {
        'mae': mae,
        'rmse': rmse,
        'aggregated_data': None
    }
    
    # If date variable provided, aggregate by date
    if date_var and date_var in data.columns:
        # Group by date and calculate means
        agg_data = data.groupby(date_var).agg({
            actual_var: 'mean',
            pred_var: 'mean'
        }).reset_index()
        
        # Rename columns to match SAS output format
        agg_data.columns = [date_var, actual_var, pred_var]
        agg_data['Type'] = 'HIST'  # Default type
        
        results['aggregated_data'] = agg_data
    
    return results

def create_performance_plot(hist_data, oot_data, actual_var, pred_var, date_var, 
                          model_name, reference_date=None):
    """
    Create performance plot similar to SAS SGPLOT
    
    Parameters:
    - hist_data: Historical (training) aggregated data
    - oot_data: Out-of-time (test) aggregated data  
    - actual_var: name of actual variable
    - pred_var: name of predicted variable
    - date_var: name of date variable
    - model_name: model name for title
    - reference_date: reference date for vertical line
    """
    # Prepare data for plotting
    plot_data = []
    
    # Add historical data
    if hist_data is not None:
        hist_actual = hist_data[[date_var, actual_var]].copy()
        hist_actual['series_name'] = f'Actual_{model_name}_HIST'
        hist_actual['value'] = hist_actual[actual_var]
        
        hist_pred = hist_data[[date_var, pred_var]].copy()
        hist_pred['series_name'] = f'Predicted_{model_name}_HIST'
        hist_pred['value'] = hist_pred[pred_var]
        
        plot_data.extend([hist_actual, hist_pred])
    
    # Add OOT data
    if oot_data is not None:
        oot_actual = oot_data[[date_var, actual_var]].copy()
        oot_actual['series_name'] = f'Actual_{model_name}_OOT'
        oot_actual['value'] = oot_actual[actual_var]
        
        oot_pred = oot_data[[date_var, pred_var]].copy()
        oot_pred['series_name'] = f'Predicted_{model_name}_OOT'
        oot_pred['value'] = oot_pred[pred_var]
        
        plot_data.extend([oot_actual, oot_pred])
    
    # Combine all data
    if plot_data:
        combined_data = pd.concat(plot_data, ignore_index=True)
        
        # Create the plot
        plt.figure(figsize=(12, 8))
        
        # Plot lines for each series
        for series in combined_data['series_name'].unique():
            series_data = combined_data[combined_data['series_name'] == series]
            
            # Determine line style and color
            if 'HIST' in series:
                linestyle = '-'
                alpha = 0.8
            else:
                linestyle = '--'
                alpha = 0.8
                
            if 'Actual' in series:
                color = 'blue' if 'HIST' in series else 'darkblue'
                marker = 'o'
            else:
                color = 'red' if 'HIST' in series else 'darkred' 
                marker = 's'
            
            plt.plot(pd.to_datetime(series_data[date_var]), series_data['value'], 
                    label=series, linewidth=2, linestyle=linestyle, 
                    color=color, marker=marker, markersize=4, alpha=alpha)
        
        # Add reference line if provided
        if reference_date:
            plt.axvline(pd.to_datetime(reference_date), color='black', 
                       linestyle='--', linewidth=2, alpha=0.7, label='Reference Date')
        
        # Formatting
        plt.xlabel('Default Date', fontsize=10)
        plt.ylabel('LGD Level', fontsize=10)
        plt.title(f'{model_name} Model - Train vs OOT Performance', fontsize=14)
        plt.ylim(0, 1)
        plt.legend(loc='upper right', bbox_to_anchor=(1, 1))
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.show()

def twostage_lgd(stage1_data, stage2_data, score_hist, score_oot, 
                id_var='loan_number', date_var='def_date', lgd_var='lgd_36m',
                stage1_vars=None, stage2_vars=None, outprefix='tg_', 
                reference_date=None, create_plots=True):
    """
    Python implementation of SAS two-stage LGD modeling macro
    Uses statsmodels to match SAS exactly
    
    Parameters:
    - stage1_data: DataFrame for stage 1 model training
    - stage2_data: DataFrame for stage 2 model training  
    - score_hist: DataFrame for historical scoring
    - score_oot: DataFrame for out-of-time scoring
    - id_var: ID variable name
    - date_var: Date variable name
    - lgd_var: LGD variable name
    - stage1_vars: List of stage 1 variables
    - stage2_vars: List of stage 2 variables  
    - outprefix: Output prefix for results
    - reference_date: Reference date for plots
    - create_plots: Whether to create performance plots
    
    Returns:
    - Dictionary with models and performance metrics only
    """
    
    results = {}
    
    # Stage 1: Probability of Loss Model
    print("=" * 60)
    print("STAGE 1 MODEL - PROBABILITY OF LOSS")
    print("=" * 60)
    
    # Prepare stage 1 data - use lgd_stage1 as target (binary: 0/1)
    stage1_y = stage1_data['lgd_stage1']
    stage1_X = stage1_data[stage1_vars]
    
    # Add constant for intercept (to match SAS)
    stage1_X_const = sm.add_constant(stage1_X)
    
    # Train stage 1 model using statsmodels (to match SAS exactly)
    stage1_model = sm.Logit(stage1_y, stage1_X_const).fit(disp=0)
    print(stage1_model.summary())
    results['stage1_model'] = stage1_model
    
    # Stage 2: E(LGD | Loss) Model  
    print("\n" + "=" * 60)
    print("STAGE 2 MODEL - E(LGD | LOSS)")
    print("=" * 60)
    
    # Prepare stage 2 data
    stage2_y = stage2_data['algd_adj']
    stage2_X = stage2_data[stage2_vars]
    
    # Add constant for intercept
    stage2_X_const = sm.add_constant(stage2_X)
    
    # Get sample weights
    sample_weights = stage2_data['wt']
    
    # Train stage 2 model with weights (to match SAS)
    stage2_model = sm.Logit(stage2_y, stage2_X_const, freq_weights=sample_weights).fit(disp=0)
    print(stage2_model.summary())
    results['stage2_model'] = stage2_model
    
    # Score Historical Data
    print("\n" + "=" * 60)
    print("SCORING AND PERFORMANCE METRICS")
    print("=" * 60)
    
    # Stage 1 scoring - get probabilities
    hist_stage1_X_const = sm.add_constant(score_hist[stage1_vars])
    hist_stage1_probs = stage1_model.predict(hist_stage1_X_const)
    
    # Stage 2 scoring
    hist_stage2_X_const = sm.add_constant(score_hist[stage2_vars])
    hist_stage2_probs = stage2_model.predict(hist_stage2_X_const)
    
    # Create scored historical dataset
    scored_hist = score_hist.copy()
    scored_hist['p_loss'] = hist_stage1_probs
    scored_hist['p_lgd'] = hist_stage2_probs
    scored_hist['pred_lgd'] = hist_stage1_probs * hist_stage2_probs
    
    # Create binary flags if missing
    if 'lgd_stage1' not in scored_hist.columns:
        scored_hist['lgd_stage1'] = (scored_hist[lgd_var] > 0).astype(int)
    if 'algd_adj' not in scored_hist.columns:
        scored_hist['algd_adj'] = (scored_hist[lgd_var] > 0).astype(int)
    
    # Score OOT Data
    # Stage 1 scoring
    oot_stage1_X_const = sm.add_constant(score_oot[stage1_vars])
    oot_stage1_probs = stage1_model.predict(oot_stage1_X_const)
    
    # Stage 2 scoring
    oot_stage2_X_const = sm.add_constant(score_oot[stage2_vars])
    oot_stage2_probs = stage2_model.predict(oot_stage2_X_const)
    
    # Create scored OOT dataset
    scored_oot = score_oot.copy()
    scored_oot['p_loss'] = oot_stage1_probs
    scored_oot['p_lgd'] = oot_stage2_probs
    scored_oot['pred_lgd'] = oot_stage1_probs * oot_stage2_probs
    
    # Create binary flags if missing
    if 'lgd_stage1' not in scored_oot.columns:
        scored_oot['lgd_stage1'] = (scored_oot[lgd_var] > 0).astype(int)
    if 'algd_adj' not in scored_oot.columns:
        scored_oot['algd_adj'] = (scored_oot[lgd_var] > 0).astype(int)
    
    # Performance Metrics
    metrics = {}
    
    # Stage 1 HIST
    stage1_hist_metrics = performance_metrics(scored_hist, 'lgd_stage1', 'p_loss', date_var)
    metrics['stage1_hist'] = stage1_hist_metrics
    print(f"Stage-1 HIST - MAE: {stage1_hist_metrics['mae']:.6f}, RMSE: {stage1_hist_metrics['rmse']:.6f}")
    
    # Stage 2 HIST - Use original lgd_var for Stage 2 actual (not algd_adj)
    stage2_hist_metrics = performance_metrics(scored_hist, lgd_var, 'p_lgd', date_var)
    metrics['stage2_hist'] = stage2_hist_metrics
    print(f"Stage-2 HIST - MAE: {stage2_hist_metrics['mae']:.6f}, RMSE: {stage2_hist_metrics['rmse']:.6f}")
    
    # Combined HIST
    combined_hist_metrics = performance_metrics(scored_hist, lgd_var, 'pred_lgd', date_var)
    metrics['combined_hist'] = combined_hist_metrics
    print(f"Combined HIST - MAE: {combined_hist_metrics['mae']:.6f}, RMSE: {combined_hist_metrics['rmse']:.6f}")
    
    # Stage 1 OOT
    stage1_oot_metrics = performance_metrics(scored_oot, 'lgd_stage1', 'p_loss', date_var)
    metrics['stage1_oot'] = stage1_oot_metrics
    print(f"Stage-1 OOT - MAE: {stage1_oot_metrics['mae']:.6f}, RMSE: {stage1_oot_metrics['rmse']:.6f}")
    
    # Stage 2 OOT - Use original lgd_var for Stage 2 actual
    stage2_oot_metrics = performance_metrics(scored_oot, lgd_var, 'p_lgd', date_var)
    metrics['stage2_oot'] = stage2_oot_metrics
    print(f"Stage-2 OOT - MAE: {stage2_oot_metrics['mae']:.6f}, RMSE: {stage2_oot_metrics['rmse']:.6f}")
    
    # Combined OOT
    combined_oot_metrics = performance_metrics(scored_oot, lgd_var, 'pred_lgd', date_var)
    metrics['combined_oot'] = combined_oot_metrics
    print(f"Combined OOT - MAE: {combined_oot_metrics['mae']:.6f}, RMSE: {combined_oot_metrics['rmse']:.6f}")
    
    results['metrics'] = metrics
    
    # Create Performance Plots
    if create_plots:
        print("\nCreating Performance Plots...")
        
        # Stage 1 Plot
        create_performance_plot(
            stage1_hist_metrics['aggregated_data'],
            stage1_oot_metrics['aggregated_data'], 
            'lgd_stage1', 'p_loss', date_var,
            'Stage-1', reference_date
        )
        
        # Stage 2 Plot - Use lgd_var for actual values
        create_performance_plot(
            stage2_hist_metrics['aggregated_data'],
            stage2_oot_metrics['aggregated_data'],
            lgd_var, 'p_lgd', date_var, 
            'Stage-2', reference_date
        )
        
        # Combined Plot
        create_performance_plot(
            combined_hist_metrics['aggregated_data'],
            combined_oot_metrics['aggregated_data'],
            lgd_var, 'pred_lgd', date_var,
            'Combined', reference_date
        )
    
    print("\nTwo-Stage LGD Modeling Complete!")
    return results

# Example usage:
"""
# Step 1: Prepare the data
staging_results = lgd_datastaging(
    orig_data=your_dataframe,
    stage1_vars=['var1', 'var2', 'var3'],
    stage2_vars=['var4', 'var5', 'var6'], 
    lgd_var='lgd_36m'
)

# Step 2: Run two-stage LGD modeling
model_results = twostage_lgd(
    stage1_data=staging_results['lgd_stage1_wf_wadj'],
    stage2_data=staging_results['lgd_stage2_wf_wadj'],
    score_hist=historical_data,
    score_oot=oot_data,
    stage1_vars=['var1', 'var2', 'var3'],
    stage2_vars=['var4', 'var5', 'var6'],
    lgd_var='lgd_36m',
    reference_date='2020-04-30'
)
"""import pandas as pd
import numpy as np
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

def lgd_datastaging(orig_data, stage1_vars, stage2_vars, lgd_var, 
                   id_var='LOAN_NUMBER', date_var='def_date'):
    """
    Python implementation of SAS lgd_datastaging macro
    Creates properly staged data for two-stage LGD modeling
    
    Parameters:
    - orig_data: Original DataFrame
    - stage1_vars: List of stage 1 variables
    - stage2_vars: List of stage 2 variables  
    - lgd_var: Name of LGD variable
    - id_var: ID variable name
    - date_var: Date variable name
    
    Returns:
    - Dictionary containing stage1, stage2, and combined datasets
    """
    
    results = {}
    
    # Stage 1 dataset
    stage1_keep_vars = stage1_vars + [lgd_var, id_var, date_var]
    lgd_stage1 = orig_data[stage1_keep_vars].copy()
    lgd_stage1['wt'] = 1
    results['lgd_stage1'] = lgd_stage1
    
    # Stage 2 dataset  
    stage2_keep_vars = stage2_vars + [lgd_var, id_var, date_var]
    lgd_stage2 = orig_data[stage2_keep_vars].copy()
    lgd_stage2['wt'] = 1
    results['lgd_stage2'] = lgd_stage2
    
    # Combined dataset with all variables
    all_vars = list(set(stage1_vars + stage2_vars + [lgd_var, id_var, date_var]))
    lgd_stage_all = orig_data[all_vars].copy()
    lgd_stage_all['wt'] = 1
    results['lgd_stage_all'] = lgd_stage_all
    
    # Adding staging flags to stage1 dataset
    lgd_stage1_wf = lgd_stage1.copy()
    
    # Create LGD category flags
    lgd_stage1_wf['lgd_0'] = (lgd_stage1_wf[lgd_var] == 0).astype(int)
    lgd_stage1_wf['lgd_1'] = (lgd_stage1_wf[lgd_var] == 1).astype(int)
    lgd_stage1_wf['lgd_0_1'] = ((lgd_stage1_wf[lgd_var] > 0) & 
                                (lgd_stage1_wf[lgd_var] < 1)).astype(int)
    lgd_stage1_wf['lgd_0_1_inc'] = ((lgd_stage1_wf[lgd_var] > 0) & 
                                    (lgd_stage1_wf[lgd_var] <= 1)).astype(int)
    
    results['lgd_stage1_wf'] = lgd_stage1_wf
    
    # Adding staging flags to stage2 dataset
    lgd_stage2_wf = lgd_stage2.copy()
    
    # Create LGD category flags (same as stage1)
    lgd_stage2_wf['lgd_0'] = (lgd_stage2_wf[lgd_var] == 0).astype(int)
    lgd_stage2_wf['lgd_1'] = (lgd_stage2_wf[lgd_var] == 1).astype(int)
    lgd_stage2_wf['lgd_0_1'] = ((lgd_stage2_wf[lgd_var] > 0) & 
                                (lgd_stage2_wf[lgd_var] < 1)).astype(int)
    lgd_stage2_wf['lgd_0_1_inc'] = ((lgd_stage2_wf[lgd_var] > 0) & 
                                    (lgd_stage2_wf[lgd_var] <= 1)).astype(int)
    
    results['lgd_stage2_wf'] = lgd_stage2_wf
    
    # Adding staging flags to combined dataset
    lgd_stage_all_wf = lgd_stage_all.copy()
    
    # Create LGD category flags (same as above)
    lgd_stage_all_wf['lgd_0'] = (lgd_stage_all_wf[lgd_var] == 0).astype(int)
    lgd_stage_all_wf['lgd_1'] = (lgd_stage_all_wf[lgd_var] == 1).astype(int)
    lgd_stage_all_wf['lgd_0_1'] = ((lgd_stage_all_wf[lgd_var] > 0) & 
                                   (lgd_stage_all_wf[lgd_var] < 1)).astype(int)
    lgd_stage_all_wf['lgd_0_1_inc'] = ((lgd_stage_all_wf[lgd_var] > 0) & 
                                       (lgd_stage_all_wf[lgd_var] <= 1)).astype(int)
    
    results['lgd_stage_all_wf'] = lgd_stage_all_wf
    
    # Stage 1 y creation
    lgd_stage1_wf_wadj = lgd_stage1_wf.copy()
    
    # Create LGD_Stage1: 1 if lgd_var = 0, 2 otherwise
    lgd_stage1_wf_wadj['LGD_Stage1'] = np.where(
        lgd_stage1_wf_wadj[lgd_var] == 0, 1, 2
    )
    
    results['lgd_stage1_wf_wadj'] = lgd_stage1_wf_wadj
    
    # Stage 2 algd_adj creation
    # Filter to only include cases where 0 < lgd_var <= 1
    mask = (lgd_stage2_wf[lgd_var] > 0) & (lgd_stage2_wf[lgd_var] <= 1)
    lgd_stage2_filtered = lgd_stage2_wf[mask].copy()
    
    # Create condition "a" rows: algd_adj=1, wt=lgd_var
    condition_a = lgd_stage2_filtered.copy()
    condition_a['algd_adj'] = 1
    condition_a['wt'] = condition_a[lgd_var]
    
    # Create condition "b" rows: algd_adj=0, wt=1-lgd_var
    condition_b = lgd_stage2_filtered.copy()
    condition_b['algd_adj'] = 0
    condition_b['wt'] = 1 - condition_b[lgd_var]
    
    # Combine both conditions
    lgd_stage2_wf_wadj = pd.concat([condition_a, condition_b], ignore_index=True)
    
    results['lgd_stage2_wf_wadj'] = lgd_stage2_wf_wadj
    
    return results

def performance_metrics(data, actual_var, pred_var, date_var=None):
    """
    Calculate performance metrics (MAE, RMSE) and return aggregated data for plotting
    
    Parameters:
    - data: DataFrame with actual and predicted values
    - actual_var: name of actual variable column
    - pred_var: name of predicted variable column  
    - date_var: name of date variable for aggregation (optional)
    
    Returns:
    - dict with MAE, RMSE, and aggregated data
    """
    # Calculate overall metrics
    mae = mean_absolute_error(data[actual_var], data[pred_var])
    rmse = np.sqrt(mean_squared_error(data[actual_var], data[pred_var]))
    
    results = {
        'mae': mae,
        'rmse': rmse,
        'aggregated_data': None
    }
    
    # If date variable provided, aggregate by date
    if date_var and date_var in data.columns:
        # Group by date and calculate means
        agg_data = data.groupby(date_var).agg({
            actual_var: 'mean',
            pred_var: 'mean'
        }).reset_index()
        
        # Rename columns to match SAS output format
        agg_data.columns = [date_var, actual_var, pred_var]
        agg_data['Type'] = 'HIST'  # Default type
        
        results['aggregated_data'] = agg_data
    
    return results

def create_performance_plot(hist_data, oot_data, actual_var, pred_var, date_var, 
                          model_name, reference_date=None):
    """
    Create performance plot similar to SAS SGPLOT
    
    Parameters:
    - hist_data: Historical (training) aggregated data
    - oot_data: Out-of-time (test) aggregated data  
    - actual_var: name of actual variable
    - pred_var: name of predicted variable
    - date_var: name of date variable
    - model_name: model name for title
    - reference_date: reference date for vertical line
    """
    # Prepare data for plotting
    plot_data = []
    
    # Add historical data
    if hist_data is not None:
        hist_actual = hist_data[[date_var, actual_var]].copy()
        hist_actual['series_name'] = f'Actual_{model_name}_HIST'
        hist_actual['value'] = hist_actual[actual_var]
        
        hist_pred = hist_data[[date_var, pred_var]].copy()
        hist_pred['series_name'] = f'Predicted_{model_name}_HIST'
        hist_pred['value'] = hist_pred[pred_var]
        
        plot_data.extend([hist_actual, hist_pred])
    
    # Add OOT data
    if oot_data is not None:
        oot_actual = oot_data[[date_var, actual_var]].copy()
        oot_actual['series_name'] = f'Actual_{model_name}_OOT'
        oot_actual['value'] = oot_actual[actual_var]
        
        oot_pred = oot_data[[date_var, pred_var]].copy()
        oot_pred['series_name'] = f'Predicted_{model_name}_OOT'
        oot_pred['value'] = oot_pred[pred_var]
        
        plot_data.extend([oot_actual, oot_pred])
    
    # Combine all data
    if plot_data:
        combined_data = pd.concat(plot_data, ignore_index=True)
        
        # Create the plot
        plt.figure(figsize=(12, 8))
        
        # Plot lines for each series
        for series in combined_data['series_name'].unique():
            series_data = combined_data[combined_data['series_name'] == series]
            
            # Determine line style and color
            if 'HIST' in series:
                linestyle = '-'
                alpha = 0.8
            else:
                linestyle = '--'
                alpha = 0.8
                
            if 'Actual' in series:
                color = 'blue' if 'HIST' in series else 'darkblue'
                marker = 'o'
            else:
                color = 'red' if 'HIST' in series else 'darkred' 
                marker = 's'
            
            plt.plot(pd.to_datetime(series_data[date_var]), series_data['value'], 
                    label=series, linewidth=2, linestyle=linestyle, 
                    color=color, marker=marker, markersize=4, alpha=alpha)
        
        # Add reference line if provided
        if reference_date:
            plt.axvline(pd.to_datetime(reference_date), color='black', 
                       linestyle='--', linewidth=2, alpha=0.7, label='Reference Date')
        
        # Formatting
        plt.xlabel('Default Date', fontsize=10)
        plt.ylabel('LGD Level', fontsize=10)
        plt.title(f'{model_name} Model - Train vs OOT Performance', fontsize=14)
        plt.ylim(0, 1)
        plt.legend(loc='upper right', bbox_to_anchor=(1, 1))
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.show()

def twostage_lgd(stage1_data, stage2_data, score_hist, score_oot, 
                id_var='loan_number', date_var='def_date', lgd_var='lgd_36m',
                stage1_vars=None, stage2_vars=None, outprefix='tg_', 
                reference_date=None, create_plots=True):
    """
    Python implementation of SAS two-stage LGD modeling macro
    
    Parameters:
    - stage1_data: DataFrame for stage 1 model training
    - stage2_data: DataFrame for stage 2 model training  
    - score_hist: DataFrame for historical scoring
    - score_oot: DataFrame for out-of-time scoring
    - id_var: ID variable name
    - date_var: Date variable name
    - lgd_var: LGD variable name
    - stage1_vars: List of stage 1 variables
    - stage2_vars: List of stage 2 variables  
    - outprefix: Output prefix for results
    - reference_date: Reference date for plots
    - create_plots: Whether to create performance plots
    
    Returns:
    - Dictionary with models, scored data, and performance metrics
    """
    
    results = {}
    
    # Stage 1: Probability of Loss Model
    print("Training Stage 1 Model - Probability of Loss...")
    
    # Prepare stage 1 data - use LGD_Stage1 as target
    stage1_y = stage1_data['LGD_Stage1'] - 1  # Convert 1,2 to 0,1
    stage1_X = stage1_data[stage1_vars] if stage1_vars else stage1_data.drop([id_var, 'LGD_Stage1', lgd_var], axis=1)
    
    # Train stage 1 model
    stage1_model = LogisticRegression(random_state=42, max_iter=1000)
    stage1_model.fit(stage1_X, stage1_y)
    results['stage1_model'] = stage1_model
    
    # Stage 2: E(LGD | Loss) Model  
    print("Training Stage 2 Model - E(LGD | Loss)...")
    
    # Prepare stage 2 data
    stage2_y = stage2_data['algd_adj']  # Adjusted LGD for positive cases
    stage2_X = stage2_data[stage2_vars] if stage2_vars else stage2_data.drop([id_var, 'algd_adj', 'wt', lgd_var], axis=1)
    
    # Get sample weights if available
    sample_weights = stage2_data['wt'] if 'wt' in stage2_data.columns else None
    
    # Train stage 2 model
    stage2_model = LogisticRegression(random_state=42, max_iter=1000)
    stage2_model.fit(stage2_X, stage2_y, sample_weight=sample_weights)
    results['stage2_model'] = stage2_model
    
    # Score Historical Data
    print("Scoring Historical Data...")
    
    # Stage 1 scoring - get P_2 (probability of loss)
    hist_stage1_X = score_hist[stage1_vars] if stage1_vars else score_hist[stage1_X.columns]
    hist_stage1_probs = stage1_model.predict_proba(hist_stage1_X)
    hist_p_loss = hist_stage1_probs[:, 1]  # P_1: probability of class 1 (loss > 0)
    
    # Stage 2 scoring - get P_1 (probability of positive LGD weights)  
    hist_stage2_X = score_hist[stage2_vars] if stage2_vars else score_hist[stage2_X.columns]
    hist_stage2_probs = stage2_model.predict_proba(hist_stage2_X)
    hist_p_lgd = hist_stage2_probs[:, 1]  # P_1: probability of class 1 (positive weights)
    
    # Create scored historical dataset
    scored_hist = score_hist.copy()
    scored_hist['p_loss'] = hist_p_loss
    scored_hist['p_lgd'] = hist_p_lgd
    scored_hist['pred_lgd'] = hist_p_loss * hist_p_lgd
    
    # Create binary flags if missing
    if 'lgd_stage1' not in scored_hist.columns:
        scored_hist['lgd_stage1'] = (scored_hist[lgd_var] > 0).astype(int)
    if 'algd_adj' not in scored_hist.columns:
        scored_hist['algd_adj'] = (scored_hist[lgd_var] > 0).astype(int)
    
    results['scored_hist'] = scored_hist
    
    # Score OOT Data
    print("Scoring OOT Data...")
    
    # Stage 1 scoring
    oot_stage1_X = score_oot[stage1_vars] if stage1_vars else score_oot[stage1_X.columns]
    oot_stage1_probs = stage1_model.predict_proba(oot_stage1_X)
    oot_p_loss = oot_stage1_probs[:, 1]
    
    # Stage 2 scoring
    oot_stage2_X = score_oot[stage2_vars] if stage2_vars else score_oot[stage2_X.columns]
    oot_stage2_probs = stage2_model.predict_proba(oot_stage2_X)
    oot_p_lgd = oot_stage2_probs[:, 1]
    
    # Create scored OOT dataset
    scored_oot = score_oot.copy()
    scored_oot['p_loss'] = oot_p_loss
    scored_oot['p_lgd'] = oot_p_lgd
    scored_oot['pred_lgd'] = oot_p_loss * oot_p_lgd
    
    # Create binary flags if missing
    if 'lgd_stage1' not in scored_oot.columns:
        scored_oot['lgd_stage1'] = (scored_oot[lgd_var] > 0).astype(int)
    if 'algd_adj' not in scored_oot.columns:
        scored_oot['algd_adj'] = (scored_oot[lgd_var] > 0).astype(int)
    
    results['scored_oot'] = scored_oot
    
    # Performance Metrics
    print("Calculating Performance Metrics...")
    
    metrics = {}
    
    # Stage 1 HIST
    stage1_hist_metrics = performance_metrics(scored_hist, 'lgd_stage1', 'p_loss', date_var)
    metrics['stage1_hist'] = stage1_hist_metrics
    print(f"Stage-1 HIST - MAE: {stage1_hist_metrics['mae']:.4f}, RMSE: {stage1_hist_metrics['rmse']:.4f}")
    
    # Stage 2 HIST  
    stage2_hist_metrics = performance_metrics(scored_hist, 'algd_adj', 'p_lgd', date_var)
    metrics['stage2_hist'] = stage2_hist_metrics
    print(f"Stage-2 HIST - MAE: {stage2_hist_metrics['mae']:.4f}, RMSE: {stage2_hist_metrics['rmse']:.4f}")
    
    # Combined HIST
    combined_hist_metrics = performance_metrics(scored_hist, lgd_var, 'pred_lgd', date_var)
    metrics['combined_hist'] = combined_hist_metrics
    print(f"Combined HIST - MAE: {combined_hist_metrics['mae']:.4f}, RMSE: {combined_hist_metrics['rmse']:.4f}")
    
    # Stage 1 OOT
    stage1_oot_metrics = performance_metrics(scored_oot, 'lgd_stage1', 'p_loss', date_var)
    metrics['stage1_oot'] = stage1_oot_metrics
    print(f"Stage-1 OOT - MAE: {stage1_oot_metrics['mae']:.4f}, RMSE: {stage1_oot_metrics['rmse']:.4f}")
    
    # Stage 2 OOT
    stage2_oot_metrics = performance_metrics(scored_oot, 'algd_adj', 'p_lgd', date_var)
    metrics['stage2_oot'] = stage2_oot_metrics
    print(f"Stage-2 OOT - MAE: {stage2_oot_metrics['mae']:.4f}, RMSE: {stage2_oot_metrics['rmse']:.4f}")
    
    # Combined OOT
    combined_oot_metrics = performance_metrics(scored_oot, lgd_var, 'pred_lgd', date_var)
    metrics['combined_oot'] = combined_oot_metrics
    print(f"Combined OOT - MAE: {combined_oot_metrics['mae']:.4f}, RMSE: {combined_oot_metrics['rmse']:.4f}")
    
    results['metrics'] = metrics
    
    # Create Performance Plots
    if create_plots:
        print("Creating Performance Plots...")
        
        # Stage 1 Plot
        create_performance_plot(
            stage1_hist_metrics['aggregated_data'],
            stage1_oot_metrics['aggregated_data'], 
            'lgd_stage1', 'p_loss', date_var,
            'Stage-1', reference_date
        )
        
        # Stage 2 Plot
        create_performance_plot(
            stage2_hist_metrics['aggregated_data'],
            stage2_oot_metrics['aggregated_data'],
            'algd_adj', 'p_lgd', date_var, 
            'Stage-2', reference_date
        )
        
        # Combined Plot
        create_performance_plot(
            combined_hist_metrics['aggregated_data'],
            combined_oot_metrics['aggregated_data'],
            lgd_var, 'pred_lgd', date_var,
            'Combined', reference_date
        )
    
    print("Two-Stage LGD Modeling Complete!")
    return results
