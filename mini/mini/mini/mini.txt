def rolling_mae(
    datasets: List[pd.DataFrame],
    frequency: str,
    excluded_quarters: Optional[List[str]] = None,
    rolling_periods: int = 4,
    date_col: str = 'date',
    column_mapping: Optional[Dict[int, Dict[str, str]]] = None,
    all_cols: Optional[Dict[str, str]] = None
) -> Dict[int, Dict[str, Union[float, pd.Series]]]:
    """
    Calculate rolling MAE with warning and breach intervals for model validation.
    
    This function computes development MAE metrics used in banking model validation
    frameworks like CCAR and CECL. It calculates rolling MAE over specified periods
    and determines statistical thresholds for model performance monitoring.
    
    Parameters:
    -----------
    datasets : List[pd.DataFrame]
        List of datasets to analyze. Each should contain date, actual, and predicted columns.
    frequency : str
        Data frequency - 'month', 'quarter', or 'year'
    excluded_quarters : List[str], optional
        Quarters to exclude in format "1q2008", "2q2009", etc.
    rolling_periods : int, default=4
        Number of periods for rolling calculation (typically 4 quarters)
    date_col : str, default='date'
        Name of date column (format: "yyyy-mm-dd")
    column_mapping : Dict[int, Dict[str, str]], optional
        Dataset-specific column mapping. Format:
        {0: {'actual_col': 'actual_loss', 'predicted_col': 'pred_loss'},
         1: {'actual_col': 'true_val', 'predicted_col': 'forecast'}}
    all_cols : Dict[str, str], optional
        Column names to use for all datasets. Format:
        {'actual_col': 'actual_var', 'predicted_col': 'predicted_var'}
        Ignored if column_mapping is provided.
        
    Returns:
    --------
    Dict[int, Dict[str, Union[float, pd.Series]]]
        Dictionary with dataset index as key, containing:
        - 'development_mae': float - Average of rolling MAE
        - 'warning_interval': float - Mean + 1 std dev
        - 'breach_interval': float - Mean + 2 std dev
        - 'rolling_mae_series': pd.Series - Complete rolling MAE time series
        - 'excluded_periods': List[str] - Periods that were excluded
    """
    
    if not datasets:
        raise ValueError("At least one dataset must be provided")
    
    if frequency.lower() not in ['month', 'quarter', 'year']:
        raise ValueError("Frequency must be 'month', 'quarter', or 'year'")
    
    if rolling_periods < 1:
        raise ValueError("Rolling periods must be at least 1")
    
    # default to standard column names if nothing specified
    if column_mapping is None and all_cols is None:
        all_cols = {'actual_col': 'actual_var', 'predicted_col': 'predicted_var'}
    
    excluded_quarters = excluded_quarters or []
    results = {}
    
    for idx, df in enumerate(datasets):
        try:
            # figure out which columns to use for this dataset
            if column_mapping and idx in column_mapping:
                actual_col = column_mapping[idx]['actual_col']
                predicted_col = column_mapping[idx]['predicted_col']
            elif all_cols:
                actual_col = all_cols['actual_col']
                predicted_col = all_cols['predicted_col']
            else:
                raise ValueError(f"No column mapping found for dataset {idx}")
            
            if df.empty:
                warnings.warn(f"Dataset {idx} is empty, skipping...")
                continue
                
            required_cols = [date_col, actual_col, predicted_col]
            missing_cols = [col for col in required_cols if col not in df.columns]
            if missing_cols:
                raise ValueError(f"Dataset {idx} missing columns: {missing_cols}")
            
            data = df.copy()
            
            data[date_col] = pd.to_datetime(data[date_col])
            data = data.sort_values(date_col).reset_index(drop=True)
            
            # set up time periods based on what user wants
            if frequency.lower() == 'quarter':
                data['period'] = data[date_col].dt.to_period('Q')
            elif frequency.lower() == 'month':
                data['period'] = data[date_col].dt.to_period('M')
            else:  # year
                data['period'] = data[date_col].dt.to_period('Y')
            
            # need this for exclusions later but don't filter yet
            data['quarter_id'] = data[date_col].dt.to_period('Q').astype(str).str.replace('Q', 'q').str.lower()
            
            # precision issues are annoying, round before calculations
            data[actual_col] = data[actual_col].round(10)
            data[predicted_col] = data[predicted_col].round(10)
            
            # collapse to period level and get means
            period_groups = data.groupby('period').agg({
                actual_col: 'mean',      
                predicted_col: 'mean',   
                'quarter_id': 'first'    
            }).reset_index()
            
            # mae between the period averages
            period_groups['period_mae'] = np.abs(period_groups[actual_col] - period_groups[predicted_col])
            
            if len(period_groups) < rolling_periods:
                warnings.warn(f"Dataset {idx} has insufficient periods ({len(period_groups)}) for rolling calculation of {rolling_periods} periods")
                continue
            
            # apply rolling window to the period maes
            period_mae_series = period_groups.set_index('period')['period_mae']
            rolling_mae_series = period_mae_series.rolling(window=rolling_periods, min_periods=rolling_periods).mean()
            
            rolling_mae_clean = rolling_mae_series.dropna()
            
            if len(rolling_mae_clean) == 0:
                warnings.warn(f"Dataset {idx} produced no valid rolling MAE values")
                continue
            
            # now handle the exclusions - just filter out the quarters we don't want
            excluded_periods = []
            if excluded_quarters:
                # convert excluded quarters from '1q2008' format to '2008q1' format to match our index
                excluded_q_formatted = []
                for q in excluded_quarters:
                    q_lower = q.lower()
                    quarter_num = q_lower[0]  # get the '1' from '1q2008'
                    year = q_lower[2:]        # get the '2008' from '1q2008'
                    excluded_q_formatted.append(f"{year}q{quarter_num}")
                
                # get quarter ids from the rolling results index
                rolling_quarter_ids = rolling_mae_clean.index.astype(str).str.replace('Q', 'q').str.lower()
                
                # simple mask to keep only the ones we want
                keep_mask = ~rolling_quarter_ids.isin(excluded_q_formatted)
                excluded_periods = rolling_quarter_ids[~keep_mask].unique().tolist()
                
                rolling_mae_final = rolling_mae_clean[keep_mask]
            else:
                rolling_mae_final = rolling_mae_clean
            
            if len(rolling_mae_final) == 0:
                warnings.warn(f"Dataset {idx} has no rolling MAE values after exclusions")
                continue
            
            # calculate the final metrics
            development_mae = rolling_mae_final.mean()
            rolling_std = rolling_mae_final.std()
            
            warning_interval = development_mae + (1 * rolling_std)
            breach_interval = development_mae + (2 * rolling_std)
            
            results[idx] = {
                'development_mae': development_mae,
                'warning_interval': warning_interval,
                'breach_interval': breach_interval,
                'rolling_mae_series': rolling_mae_final,
                'excluded_periods': excluded_periods,
                'periods_used': len(period_groups),
                'rolling_periods_calculated': len(rolling_mae_final),
                # stuff for debugging when things go wrong
                'debug_period_groups': period_groups,
                'debug_rolling_mae_clean': rolling_mae_clean,
                'debug_rolling_mae_final': rolling_mae_final
            }
            
        except Exception as e:
            warnings.warn(f"Error processing dataset {idx}: {str(e)}")
            continue
    
    # Print results automatically
    if results:
        print("=" * 70)
        print("ROLLING MAE VALIDATION RESULTS")
        print("=" * 70)
        
        for dataset_idx, metrics in results.items():
            dev_mae = metrics['development_mae']
            warn_thresh = metrics['warning_interval']
            breach_thresh = metrics['breach_interval']
            
            print(f"\nDataset {dataset_idx}:")
            print(f"  Development MAE: {dev_mae:.6f}")
            print(f"  Good interval: MAE < {warn_thresh:.6f}")
            print(f"  Warning: {warn_thresh:.6f} <= MAE < {breach_thresh:.6f}")
            print(f"  Breach: MAE >= {breach_thresh:.6f}")
            print(f"  Data points used: {metrics['periods_used']}")
            print(f"  Rolling calculations: {metrics['rolling_periods_calculated']}")
            
            if metrics['excluded_periods']:
                print(f"  Excluded periods: {', '.join(metrics['excluded_periods'])}")
    else:
        print("No valid results to display - check your data and parameters")
    
    return results
